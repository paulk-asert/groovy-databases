@Grab('org.hsqldb:hsqldb:2.3.2')
import groovy.sql.Sql
import groovy.transform.Field
import org.hsqldb.jdbc.JDBCDataSource
import java.util.logging.*

@Lazy @Field Sql sql = new Sql(new JDBCDataSource(
        database: 'jdbc:hsqldb:mem:GIA', user: 'sa', password: ''))

def reset() {
  sql.execute '''
    DROP   TABLE Athlete IF EXISTS;
    CREATE TABLE Athlete (
      athleteId   INTEGER GENERATED BY DEFAULT AS IDENTITY,
      firstname   VARCHAR(64),
      lastname    VARCHAR(64),
      dateOfBirth DATE,
      UNIQUE(athleteId)
    );
  '''
  sql.execute '''
    DROP   INDEX idx IF EXISTS;
    CREATE INDEX idx ON Athlete (athleteId);
  '''
  sql.execute '''
    DROP   TABLE Run IF EXISTS;
    CREATE TABLE Run (
      runId       INTEGER GENERATED BY DEFAULT AS IDENTITY,
      distance    INTEGER,    -- in meters
      time        INTEGER,    -- in seconds
      venue       VARCHAR(64),
      whenRun     DATE,
      fkAthlete   INTEGER,
      CONSTRAINT fk FOREIGN KEY (fkAthlete)
        REFERENCES Athlete (athleteId) ON DELETE CASCADE
    );
  '''
}

def insertRun(h, m, s, venue, date, lastname) {
  def time = h * 60 * 60 + m * 60 + s
  sql.execute """
    INSERT INTO Run (distance, time, venue, whenRun, fkAthlete)
      SELECT 42195, $time, $venue, $date,
        athleteId FROM Athlete WHERE lastname=$lastname
  """
}

def insertAthlete(firstname, lastname, dateOfBirth) {
  String athleteInsert = '''
    INSERT INTO Athlete (firstname, lastname, dateOfBirth) VALUES (?,?,?)
  '''
  sql.execute athleteInsert, [firstname, lastname, dateOfBirth]
}

def insertTestData() {
  insertAthlete('Paul', 'Tergat', '1969-06-17')
  insertAthlete('Khalid', 'Khannouchi', '1971-12-22')
  insertAthlete('Ronaldo', 'da Costa', '1970-06-07')
  insertRun(2, 4, 55, 'Berlin', '2003-09-28', 'Tergat')
  insertRun(2, 5, 38, 'London', '2002-04-14', 'Khannouchi')
  insertRun(2, 5, 42, 'Chicago', '1999-10-24', 'Khannouchi')
  insertRun(2, 6, 05, 'Berlin', '1998-09-20', 'da Costa')
  println sql.updateCount
}

Logger.getLogger('groovy.sql').level = Level.FINE
reset()
insertTestData()

sql.execute '''
  CREATE FUNCTION SELECT_ATHLETE_RUN ()
  RETURNS TABLE (lastname VARCHAR(64), venue VARCHAR(64), whenRun DATE)
  READS SQL DATA
  RETURN TABLE (
    select Athlete.lastname, Run.venue, Run.whenRun
    from Athlete, Run
    where Athlete.athleteId = Run.fkAthlete
    order by whenRun
  )
'''
sql.eachRow('CALL SELECT_ATHLETE_RUN()') {
  println "$it.lastname $it.venue $it.whenRun"
}
//da Costa Berlin 1998-09-20
//Khannouchi Chicago 1999-10-24
//Khannouchi London 2002-04-14
//Tergat Berlin 2003-09-28

sql.execute '''
  CREATE FUNCTION FULL_NAME (p_lastname VARCHAR(64))
  RETURNS VARCHAR(100)
  READS SQL DATA
  BEGIN ATOMIC
    declare ans VARCHAR(100);
    SELECT CONCAT(firstname, ' ', lastname) INTO ans
    FROM Athlete WHERE lastname = p_lastname;
    return ans;
  END
'''

assert sql.firstRow("{? = call FULL_NAME(?)}",
    ['Tergat'])[0] == 'Paul Tergat'

sql.execute '''
  CREATE PROCEDURE CONCAT_NAME (OUT fullname VARCHAR(100),
    IN first VARCHAR(50), IN last VARCHAR(50))
  BEGIN ATOMIC
    SET fullname = CONCAT(first, ' ', last);
  END
'''

sql.call("{call CONCAT_NAME(?, ?, ?)}",
    [Sql.VARCHAR, 'Paul', 'Tergat']) {
  fullname -> assert fullname == 'Paul Tergat'
}

/////////////////////////// Advanced Reading
def dump(tablename) {
    println " CONTENT OF TABLE ${tablename} ".center(40, '-')
    sql.eachRow('SELECT * FROM ' + tablename) { rs ->
        def meta = rs.getMetaData()
        if (meta.columnCount <= 0) return
        for (i in 0..<meta.columnCount) {
            print "${i}: ${meta.getColumnLabel(i + 1)}".padRight(20)  // counts from 1
            print rs[i]?.toString()               // counts from 0
            print "\n"
        }
        println '-' * 40
    }
}

def dump2(tablename) {
    def printColNames = { meta ->
        def width = meta.columnCount * 18
        println " CONTENT OF TABLE ${tablename} ".center(width, '-')
        (1..meta.columnCount).each {
            print meta.getColumnLabel(it).padRight(18)
        }
        println()
        println '-' * width
    }
    def printRow = { row ->
        row.toRowResult().values().each {
            print it.toString().padRight(18) }
        println()
    }
    sql.eachRow('SELECT * FROM ' + tablename, printColNames, printRow)
}


qry = 'SELECT * FROM Athlete'
assert sql.rows(qry, 1, 4)*.lastname ==
        ['Tergat', 'Khannouchi', 'da Costa', 'Gebrselassie']
assert sql.rows(qry, 5, 4)*.lastname ==
        ['Makau', 'Radcliffe', 'Ndereba', 'Takahashi']
assert sql.rows(qry, 9, 4)*.lastname ==
        ['Loroupe', 'Kristiansen']

/////////////////////////// End Advanced Reading
