@Grab('com.h2database:h2:1.4.181')
import groovy.sql.Sql
import groovy.transform.Canonical
import groovy.transform.Field
import org.h2.jdbcx.JdbcDataSource
import java.util.logging.*

@Field Sql sql = new Sql(new JdbcDataSource(
    URL: 'jdbc:h2:mem:GIA;DB_CLOSE_DELAY=-1', user: 'sa', password: ''))

def reset() {
def FULL_DLL = '''
    DROP   TABLE Athlete IF EXISTS;
    CREATE TABLE Athlete (
      athleteId   INTEGER GENERATED BY DEFAULT AS IDENTITY,
      firstname   VARCHAR(64),
      lastname    VARCHAR(64),
      dateOfBirth DATE
    );
    DROP   INDEX idx IF EXISTS;
    CREATE INDEX idx ON Athlete (athleteId);
    DROP   TABLE Run IF EXISTS;
    CREATE TABLE Run (
      runId       INTEGER GENERATED BY DEFAULT AS IDENTITY,
      distance    INTEGER,    -- in meters
      time        INTEGER,    -- in seconds
      venue       VARCHAR(64),
      when        TIMESTAMP,
      fkAthlete   INTEGER,
      CONSTRAINT fk FOREIGN KEY (fkAthlete)
        REFERENCES Athlete (athleteId) ON DELETE CASCADE
    );
    '''
sql.execute FULL_DLL
}

def insertRun(h, m, s, venue, date, lastname) {
  def time = h * 60 * 60 + m * 60 + s
  sql.execute """
    INSERT INTO Run (distance, time, venue, when, fkAthlete)
      SELECT 42195, $time, $venue, $date,
        athleteId FROM Athlete WHERE lastname=$lastname
  """
}

def insertAthlete(firstname, lastname, dateOfBirth) {
  String athleteInsert = '''
    INSERT INTO Athlete (firstname, lastname, dateOfBirth)
           VALUES (?,?,?)
    '''
  sql.execute athleteInsert, [firstname, lastname, dateOfBirth]
}

def insertTestData() {
insertAthlete('Paul', 'Tergat', '1969-06-17')
insertAthlete('Khalid', 'Khannouchi', '1971-12-22')
insertAthlete('Ronaldo', 'da Costa', '1970-06-07')
insertRun(2, 4, 55, 'Berlin', '2003-09-28', 'Tergat')
insertRun(2, 5, 38, 'London', '2002-04-14', 'Khannouchi')
insertRun(2, 5, 42, 'Chicago', '1999-10-24', 'Khannouchi')
insertRun(2, 6, 05, 'Berlin', '1998-09-20', 'da Costa')
  println sql.updateCount
}

def dump(tablename) {
  println " CONTENT OF TABLE ${tablename} ".center(40, '-')
  sql.eachRow('SELECT * FROM ' + tablename) { rs ->
    def meta = rs.getMetaData()
    if (meta.columnCount <= 0) return
    for (i in 0..<meta.columnCount) {
      print "${i}: ${meta.getColumnLabel(i + 1)}".padRight(20)  // counts from 1
      print rs[i]?.toString()               // counts from 0
      print "\n"
    }
    println '-' * 40
  }
}

def dump2(tablename) {
  def printColNames = { meta ->
    def width = meta.columnCount * 18
    println " CONTENT OF TABLE ${tablename} ".center(width, '-')
    (1..meta.columnCount).each {
      print meta.getColumnLabel(it).padRight(18)
    }
    println()
    println '-' * width
  }
  def printRow = { row ->
    row.toRowResult().values().each {
      print it.toString().padRight(18) }
    println()
  }
  sql.eachRow('SELECT * FROM ' + tablename, printColNames, printRow)
}

def assertAthleteCount(int count) {
  assert sql.rows('SELECT * FROM Athlete').size() == count
}

Logger.getLogger('groovy.sql').level = Level.FINE
reset()
insertTestData()
dump2 'Athlete'
////////////////// Advanced Writing
sql.withTransaction {
  insertAthlete('Haile', 'Gebrselassie', '1973-04-18')
  insertAthlete('Patrick', 'Makau', '1985-03-02')
}

sql.execute "delete from Athlete where lastname = 'Tergat'"

sql.withBatch { stmt ->
  stmt.addBatch '''
    INSERT INTO Athlete (firstname, lastname, dateOfBirth)
    VALUES ('Paul',   'Tergat', '1969-06-17')'''
  stmt.addBatch """
    INSERT INTO Run (distance, time, venue, when, fkAthlete)
      SELECT 42195, ${2*60*60+4*60+55}, 'Berlin', '2003-09-28',
      athleteId FROM Athlete WHERE lastname='Tergat'"""
}
//22/04/2013 6:34:59 AM groovy.sql.BatchingStatementWrapper processResult
//FINE: Successfully executed batch with 2 command(s)

def qry = 'INSERT INTO Athlete (firstname, lastname, dateOfBirth) VALUES (?,?,?);'
sql.withBatch(3, qry) { ps ->
  ps.addBatch('Paula', 'Radcliffe', '1973-12-17')
  ps.addBatch('Catherine', 'Ndereba', '1972-07-21')
  ps.addBatch('Naoko', 'Takahashi', '1972-05-06')
  ps.addBatch('Tegla', 'Loroupe', '1973-05-09')
  ps.addBatch('Ingrid', 'Kristiansen', '1956-03-21')
}
// If logging is turned on:
// 20/04/2013 2:18:10 AM groovy.sql.BatchingStatementWrapper processResult
// FINE: Successfully executed batch with 3 command(s)
// 20/04/2013 2:18:10 AM groovy.sql.BatchingStatementWrapper processResult
// FINE: Successfully executed batch with 2 command(s)

dump 'Athlete'
assertAthleteCount(10)
qry = 'SELECT * FROM Athlete'
assert sql.rows(qry, 1, 4)*.lastname ==
    ['Tergat', 'Khannouchi', 'da Costa', 'Gebrselassie']
assert sql.rows(qry, 5, 4)*.lastname ==
    ['Makau', 'Radcliffe', 'Ndereba', 'Takahashi']
assert sql.rows(qry, 9, 4)*.lastname ==
    ['Loroupe', 'Kristiansen']

reset()
//assertAthleteCount(0)
@Canonical class Athlete { String first, last, dob }
def ndereba = new Athlete('Catherine', 'Ndereba', '1972-07-21')
def takahashi = new Athlete('Naoko', 'Takahashi')
def takahashiExtra = [dob: '1972-05-06']
def loroupe = [first: 'Tegla', last: 'Loroupe', dob: '1973-05-09']

def insertPrefix = 'INSERT INTO Athlete (firstname, lastname, dateOfBirth) VALUES '
sql.execute insertPrefix + ' (?.first,?.last,?.dob)', ndereba
sql.execute insertPrefix + ' (?1.first,?1.last,?2.dob)', takahashi, takahashiExtra
sql.execute insertPrefix + ' (:first,:last,:dob)', loroupe
sql.execute insertPrefix + ' (:first,:last,:dob)', first: 'Ingrid',
  last: 'Kristiansen', dob: '1956-03-21'
//assertAthleteCount(4)
////////////////// End Advanced Writing

sql.execute('CREATE ALIAS getVersion FOR "org.h2.engine.Constants.getVersion"')
println sql.firstRow('CALL getVersion()')
assert sql.firstRow('CALL getVersion()')[0] =~ /1\.3\.\d{3}/
